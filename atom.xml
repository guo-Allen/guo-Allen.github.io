<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Allen&#39;s Notes</title>
  <subtitle>(*@ο@*) 哇～) 好大坨knowledge</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-12-23T13:27:46.826Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>郭恒凯</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MVC及MVVC 在Angular中的思想</title>
    <link href="http://yoursite.com/2016/12/23/MVC%20%E5%8F%8A%20MVVM%20%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2016/12/23/MVC 及 MVVM 思想/</id>
    <published>2016-12-23T13:27:46.825Z</published>
    <updated>2016-12-23T13:27:46.826Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MVC-的基本概念"><a href="#MVC-的基本概念" class="headerlink" title="MVC 的基本概念"></a>MVC 的基本概念</h3><ul>
<li><p>概念解释</p>
<ul>
<li>M Model, 模型, 数据</li>
<li>V View, 视图, 就是如何展示数据</li>
<li>C Controller, 控制器, 表上如何联系数据与展示. 可以认为是主要的代码逻辑区域.</li>
</ul>
</li>
<li><p>使用 MVC 的思想处理代码, 可以使得代码分工变得明确, 那么代码的组织方式可以根据不同分块进行单独处理,所以 在 ng 中, 提供了一个非常不同于以往的编程方法</p>
<ul>
<li>在 ng 中完全遵循 MVC 的思想, 将 html 当做展示数据的 View, 而 需要在 界面中展示的数据就是 modle.</li>
<li>在处理文本输入绑定的时候, 输入的文本内容就是数据. 所在凡是需要作为数据的标签可以利用 ng-model </li>
<li>给它取一个名字. 在有了名字以后, 代码的背后就会对应的创建一个 该名字的 Model 出来. 在数据发生变化的时候, 为了可以展示数据, 会自动的将数据展示到 界面中( 控制器 )</li>
</ul>
</li>
</ul>
<h3 id="ng弱化了控制器"><a href="#ng弱化了控制器" class="headerlink" title="ng弱化了控制器"></a>ng弱化了控制器</h3><ul>
<li>在 传统的 MVC 框架中, 控制器是联系 view 与 model 的桥梁, 一般书写代码都在控制器中. 在控制器里面调用使用视图与数据模型. 在 ng 中似乎弱化了控制器的功能.</li>
<li>在 MVC 的思想中有两个基本问题<br>  1&gt; 数据如何同步<br>  2&gt; 业务逻辑如何实现在 ng 中所谓控制器的功能实际上表现出来的只有 模块功能的管理作用.</li>
</ul>
<h3 id="ng是MVVM-框架"><a href="#ng是MVVM-框架" class="headerlink" title="ng是MVVM 框架"></a>ng是MVVM 框架</h3><ul>
<li><p>MVVM是Model-View-ViewModel的简写,MVVM（Model-View-ViewModel）框架的由来便是MVP（Model-View-Presenter）模式与WPF结合的应用方式时发展演变过来的一种新型架构框架。它立足于原有MVP框架并且把WPF的新特性糅合进去，以应对客户日益复杂的需求变化。</p>
</li>
<li><p>正因为, ng减少了控制器的作用, 但是引入了一个新的对象, 这个对象与界面中数据一一对应,并且支持数据的双向绑定. 这样的一个对象与 Model 还是有一定的区别. 这个对象称为ViewModel, 基于视图的数据模型.虽然因此弱化了 controller 的概念, 但是强化了 viewmodel 的功能. 因此有人称 ng 是 MVVM 框架.</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;MVC-的基本概念&quot;&gt;&lt;a href=&quot;#MVC-的基本概念&quot; class=&quot;headerlink&quot; title=&quot;MVC 的基本概念&quot;&gt;&lt;/a&gt;MVC 的基本概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;概念解释&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;M Model, 模型, 数据
    
    </summary>
    
      <category term="angulat" scheme="http://yoursite.com/categories/angulat/"/>
    
    
      <category term="angular" scheme="http://yoursite.com/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>angular中$scope作用域</title>
    <link href="http://yoursite.com/2016/12/23/angular%E4%B8%AD%20$scope%20%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2016/12/23/angular中 $scope 作用域/</id>
    <published>2016-12-23T13:26:49.262Z</published>
    <updated>2016-12-23T13:26:49.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用域-scope"><a href="#作用域-scope" class="headerlink" title="作用域 scope"></a>作用域 scope</h2><ul>
<li><p>作用域对象<br>就是 $scope<br>-&gt; 什么时候创建 $scope<br>  在 ng 凡是有 控制器就有 $scope 存在.<br>  在 ng 中还有一个特点, 就是懒加载, 也就是说无论是什么对象只有在使用的时候被创建.</p>
<p>-&gt; 多个 $scope 之间的 关系是什么<br>  在 ng 中 控制器可以分配作用域, 即凡是定义一个 控制器 就会创建 一个 $scope. 如果控制器有<br>  嵌套( 在一个 控制器里定义另一个控制器 ), 那么内控制器的 $scope 原型继承自 外控制器的 $scope</p>
<p>  对象 a 原型继承自 对象 b, 就是说 a 可以使用 b 中的方法, a 的 <strong>proto</strong> 就是 b<br>  Object.create( b ) -&gt; a</p>
<p>  在 原型继承中 如果 父对象 与 子对象 同时具有同名的属性会怎样?<br>  -&gt; 在 原型继承中 子对象可以继承访问 父对象的所有成员</p>
<pre><code>var base = { name: &apos;jim&apos; };
var sub = Object.create( base );
console.log( sub.name );
</code></pre><p>  -&gt; 如果在原型继承中 修改或设置 子对象的属性, 相当于给当前对象增加了属性.</p>
<pre><code>sub.age = 19;
</code></pre><p>  -&gt; 如果修改或设置 子对象中 与 父对象同名的属性, 实际上父对象不变, 而是给子对象增加了对应的属性</p>
<pre><code>sub.name = &apos;tom&apos;;
// 除非 sub.__proto__.name = &apos;tom&apos;

根据属性搜索原则, 在利用子对象访问 name 属性的时候, 只操作子对象, 与父对象无关.

需要具备一个能力, 看 html 标签 绘制 scope 关系
</code></pre></li>
</ul>
<p>  -&gt; 为什么一开始的代码中没有写 controller 也可以双向绑定<br>      在 ng 程序中, 一旦使用 了 ng-app 就表明该标签与其子标签被 ng 处理<br>      实际上在背后, 凡是有了 ng-app 的背后都会被创建一个 $rootScope 的对象<br>      它就是所有的 $scope 的祖宗, 所有的 $scope 都是直接或间接继承与 $rootScope 的</p>
<pre><code>凡是没有写 ng-controller 的 ng-model 都是 $rootScope 的属性

这个 $rootScope 是程序一开始被创建的, 因此不是使用 controller 来访问
ng 的 module 有一个方法, 叫做 run(), 表示运行, 即 ng 程序一运行的时候就会
执行该方法.

语法: 
    module.run( [ &apos;...&apos;, function ( ... ) { ... } ] )
</code></pre><ul>
<li>作用域继承</li>
</ul>
<ul>
<li>搭建本地 http 服务器<br>1&gt; 在 node 官网下载 node 安装包<br>  下载 .msi 格式的需要双击安装<br>  如果下载 zip 格式的 可以配置命令行手动安装<br>2&gt; 下一步下一步安装<br>  安装完成以后, 验证是否安装成功使用<br>  node -v<br>  npm -v<br>3&gt; 安装成功后使用 安装 hs 服务器软件<br>  npm install -g http-server<br>4&gt; 使用 shift + 右键 菜单中可以看到 在当前目录下 打开命令行<br>5&gt; 键入 hs -o 或 http-server -o 可以打开服务,在 当前目录下搭建 http 服务器, 并打开页面<br>  默认载入 index.html 文件</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;作用域-scope&quot;&gt;&lt;a href=&quot;#作用域-scope&quot; class=&quot;headerlink&quot; title=&quot;作用域 scope&quot;&gt;&lt;/a&gt;作用域 scope&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;作用域对象&lt;br&gt;就是 $scope&lt;br&gt;-&amp;gt; 什么时候创
    
    </summary>
    
      <category term="angulat" scheme="http://yoursite.com/categories/angulat/"/>
    
    
      <category term="angular" scheme="http://yoursite.com/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>angular 基础思想</title>
    <link href="http://yoursite.com/2016/12/23/angular%20%E5%9F%BA%E7%A1%80%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2016/12/23/angular 基础思想/</id>
    <published>2016-12-23T13:23:17.436Z</published>
    <updated>2016-12-23T13:25:19.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="angular-官方"><a href="#angular-官方" class="headerlink" title="angular 官方"></a>angular 官方</h2><ul>
<li>ng 表示 AngularJS.</li>
<li>官方网站<ul>
<li><a href="https://angularjs.org" target="_blank" rel="external">angular官网</a> </li>
<li><a href="https://code.angularjs.org/" target="_blank" rel="external">源代码</a><a id="more"></a>  
</li>
</ul>
</li>
</ul>
<h2 id="angular-基础"><a href="#angular-基础" class="headerlink" title="angular 基础"></a>angular 基础</h2><ul>
<li><p>angular 是什么东西</p>
<ul>
<li><p>ng 是一个处理单页面应用程序的 框架. 它扩展了原有的 HTML , 使用标签模板指令等方法去实现动态的单页面应用程序.</p>
</li>
<li><p>要理解angular,就得先理解框架和库<br>库, 就是仓库, 是一堆按照功能分类的方法, 对象数据的集合. 其目的是将用户开发的代码简化方便.<br>框架, 框架是一种结构. 该结构规定了用户应该如何使用, 按照这个结构编写代码.</p>
</li>
<li><p>什么是单页面应用程序 single page application<br>所谓的单页面应用程序是整个页面站点, 无论是什么页面内容都是一个 HTML 文件, 在 HTML 文件的内部<br>操作数据的显示与变化. 所有数据改动不再使用刷新的方法, 而是利用 ajax 和 dom 操作在界面上进行调整.</p>
</li>
<li><p>ng 不推荐在代码中使用 DOM 操作. 因此一般在 ng 项目中很少使用 DOM 操作. </p>
</li>
</ul>
</li>
<li><p>ng 代码的背后是如何执行的</p>
<pre><code>ng 是一个完全遵循 MVC( MVVM ) 的框架. 那么提供了一个开发的模型
凡是使用 ng 开发, 所有的处理都应该放在 ng-app 中, 也就是我们所说的模块中.
只要有了模块, ng 这个框架会给我们创建很多的东西来完成数据的双向绑定( 同步 ).

在实际开发时候, 一般一个页面中会包含很多的功能, 在 ng 中每一个具体功能由 控制器 维护.
在 ng 的代码中有一个属性 ng-controller, 该属性会提供一个具体的函数, 在函数中处理数据. 
</code></pre><p>  ng 的一般开发的代码结构就出现了</p>
<pre><code>1&gt; 页面中必须有 ng-app, 而且都会自己命名
2&gt; 页面中都会有 ng-controller, 因此使用 ng-controller 就有一个 $scope, 可以控制数据
3&gt; 页面的 ng-controller 中都有 ng-model, ng-model 书写数据就会是 $scope 的属性
4&gt; 代码中一定有一个 angular.module( &apos;ng-app名字&apos;, [] ) 来创建模块
5&gt; 使用 .controller( &apos;控制器的名字&apos;, 函数 ) 来定义控制器. 以便得到 $scope, 可以操作数据.
</code></pre></li>
</ul>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><pre><code>创建对象的方法很多, 常用的是 构造函数( 构造器, constructor ), 和工厂( factory )模式
所以在代码中, 创建对象的函数, 常常称为工厂函数, 利用工厂函数创建对象的设计模式就是工厂模式
Object.create(  )

依赖注入
  所谓的依赖就是指, 在实现某些功能的时候, 需要某些特定的对象.
  所谓的注入, 就是需要某个对象的时候, 作为参数传入

  因此依赖注入就是, 在需要使用某一个对象的时候, 利用参数传入即可

依赖注入的实现原理
1&gt; ng 在运行的时候, 会跟我们创建很多对象
2&gt; 这些对象都是私有的

在 ng 中可以被注入的对象有两类, 一类是 provider, 一类是服务( services )
</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ol>
<li><p>如何定义模块<br> angular.module( ‘模块名’, [] )<br> 在一个 app 中可以定义多个模块, 定义多个模块的时候命名有讲究<br> 例如: 整个 ng-app 叫做 mainApp</p>
<pre><code>一个登陆的模块可以叫做 mainApp.login
</code></pre></li>
<li><p>如何获取模块<br> angular.module( ‘模块名’ );<br> 在 ng 中无论代码是否在闭包中, 凡是已经定义的模块, 都可以获取.</p>
</li>
<li><p>控制器<br> 语法:<br> module.controller( ‘控制器名’, </p>
<pre><code>[ &apos;需要依赖注入的对象的名字&apos;, ..., 
   function ( 依赖列表 ) {

   } ] )
</code></pre><p> 简化写法<br> module.controller( ‘控制器名’, function ( 依赖名字列表 ) {</p>
<p> });</p>
<p> function ( $scope, $http ) { … }<br> =&gt;<br> [ ‘$scope’, ‘$http’, function ( $scope, $http ) { … } ] </p>
</li>
<li><p>问题<br> -&gt; 为什么函数内的参数可以随意取名字<br>   假设内部在调用这个数组的时候, 采用的是语法</p>
<pre><code>run( [ &apos;$scope&apos;, &apos;$http&apos;, function ( $scope, $http ) { ... } ] )
假设 run 函数的定义为
  function run( args ) {
    ...
  }
</code></pre><p>   在 数组中 除了最后一个以外, 都是需要被注入的对象的名字</p>
<pre><code>1&gt; 将名字全部取出
    var names = args.slice( 0, args.length - 1 )
2&gt; 利用名字在 ng 内部找寻 ( 创建 ) 对应的对象
3&gt; 获得到对象以后, 也是一个数组的形式
    var depObjs = names.map(function ( v, i ) {
      ... 在内部查找, 找到后返回
    });
4&gt; 调用最终的那个函数
  -&gt; 获得函数
    func = args[ args.length - 1 ];
  -&gt; 调用
    func.apply( ..., depObjs )

和正常的函数一样, 函数的参数只是在函数内部需要使用传入数据时所用的名字, 它只是被内部数据所依赖.
  function ( $scope ) { ... }
  =&gt;
  function ( scope ) { ... } 
</code></pre></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;angular-官方&quot;&gt;&lt;a href=&quot;#angular-官方&quot; class=&quot;headerlink&quot; title=&quot;angular 官方&quot;&gt;&lt;/a&gt;angular 官方&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;ng 表示 AngularJS.&lt;/li&gt;
&lt;li&gt;官方网站&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://angularjs.org&quot;&gt;angular官网&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://code.angularjs.org/&quot;&gt;源代码&lt;/a&gt;
    
    </summary>
    
      <category term="angulat" scheme="http://yoursite.com/categories/angulat/"/>
    
    
      <category term="angular" scheme="http://yoursite.com/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>JS中 异常</title>
    <link href="http://yoursite.com/2016/12/23/Js%E4%B8%AD%E5%BC%82%E5%B8%B8%20exception%20/"/>
    <id>http://yoursite.com/2016/12/23/Js中异常 exception /</id>
    <published>2016-12-23T13:16:20.581Z</published>
    <updated>2016-12-23T13:16:20.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是异常？"><a href="#什么是异常？" class="headerlink" title="什么是异常？"></a>什么是异常？</h2><ol>
<li>程序执行是出现的结果与预期结果不一致.</li>
<li>运行时出现了错误</li>
</ol>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><pre><code>要知道代码错在哪里，首先就要明白代码的执行顺序， 在 js 中程序的运行分成预解析与执行两个阶段
   1&gt; 在预解析过程中出现的错误, 多半是 语法. 这一类错误是无法处理的.
   2&gt; 只有在运行时出现的错误才可以被 try-catch
</code></pre><h2 id="找错喽"><a href="#找错喽" class="headerlink" title="找错喽"></a>找错喽</h2><ol>
<li><p>throw new Error( ‘错误的消息’ )<br>人为的抛出异常会阻止其后的代码执行. 和内置的异常逻辑是一模一样的.</p>
<p>异常的抛出顺序<br> func( ) -&gt; fun() -&gt; foo() -&gt; fn();<br> 在 实际开发中 常常是 函数调用函数, 利用多层调用来实现具体 的内容<br> 将调用的函数称为调用者, 而被调用的函数称为被调用者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function foo1() &#123;</div><div class="line">      console.log( &apos;foo1 Start &apos;);</div><div class="line">      foo2();</div><div class="line">      console.log( &apos;foo1 finish &apos;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  function foo2() &#123;</div><div class="line">      console.log( &apos;foo2 Start &apos;);</div><div class="line">      try &#123;</div><div class="line">          foo3();</div><div class="line">      &#125; catch ( e ) &#123;</div><div class="line"></div><div class="line">      &#125;</div><div class="line">      console.log( &apos;foo2 finish &apos;);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">   function foo3() &#123;</div><div class="line">      console.log( &apos;foo3 Start &apos;);</div><div class="line">      throw new Error( &apos;我是一个自定义异常&apos; );</div><div class="line"></div><div class="line">      console.log( &apos;foo3 finish &apos;);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  foo1();</div><div class="line">  console.log( &apos;over&apos; );</div></pre></td></tr></table></figure>
<p> 在异常发出的时候, 首先会在当前函数中寻找是否有 try-catch<br> 如果发现已经处理了异常 就没有任何影响. 如果没有出现 try-catch<br> 那么其后代码不在执行, 跳转到其调用函数, 检查是否出现 try-catch<br> 如果有, 则继续运行( 原函数中异常之后的代码, 还是不执行 )<br> 如果没有出现 try-catch, 则继续往上抛出. 直至全局范围, 若出现错误则爆红停止运行</p>
<ol>
<li><p>什么时候使用 throw 抛出异常<br>1&gt; 写一个函数是为了使用函数进行计算等运行. 因此需要输入数据, 而在实际开发中函数没有( 少用 )无效的函数.<br>  一般函数的返回值是需要用来做其他事情的. 那么为了保证函数可以正常返回数据. 因此可以利用一次判断限制函数传入的参数是否正确, 否则抛出异常, 让其后的代码不在执行.</p>
<p>  例如: Person( name, age, gender )</p>
<p>  function Person ( name, age, gender ) {</p>
<pre><code>if ( typeof name == &apos;string&apos; &amp;&amp; typeof age == &apos;number&apos; &amp;&amp; typeof gender === &apos;string&apos; ) {
  throw new Error( &apos;.... 参数不正确&apos; );
}
</code></pre></li>
</ol>
</li>
</ol>
<pre><code>      // 其后的代码
    }
2&gt; 系统定义的内置异常不够使用的时候

在 js 中 try-catch 语法有 3 中( 知道即可 )
  try-catch

  try {

  } catch ( e ) {

  } finally { // 永远会执行

  }

  try {

  } finally {

  }
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是异常？&quot;&gt;&lt;a href=&quot;#什么是异常？&quot; class=&quot;headerlink&quot; title=&quot;什么是异常？&quot;&gt;&lt;/a&gt;什么是异常？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;程序执行是出现的结果与预期结果不一致.&lt;/li&gt;
&lt;li&gt;运行时出现了错误&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="NodeJs" scheme="http://yoursite.com/categories/NodeJs/"/>
    
    
      <category term="NodeJs" scheme="http://yoursite.com/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>关于跨域</title>
    <link href="http://yoursite.com/2016/12/18/%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2016/12/18/跨域/</id>
    <published>2016-12-17T17:06:31.582Z</published>
    <updated>2016-12-08T08:07:11.710Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h2><blockquote>
<p>要了解跨域,首先就要知道什么是同源?</p>
</blockquote>
<p>所谓同源是指，域名，协议，端口完全相同<br><a id="more"></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//URL	说明	是否允许通信</span></div><div class="line">http:<span class="comment">//www.a.com/a.js</span></div><div class="line">http:<span class="comment">//www.a.com/b.js	//同一域名下	允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com/lab/a.js</span></div><div class="line">http:<span class="comment">//www.a.com/script/b.js	//同一域名下不同文件夹	允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com:8000/a.js</span></div><div class="line">http:<span class="comment">//www.a.com/b.js	//同一域名，不同端口	不允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com/a.js</span></div><div class="line">https:<span class="comment">//www.a.com/b.js	//同一域名，不同协议	不允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com/a.js</span></div><div class="line">http:<span class="comment">//70.32.92.74/b.js	//域名和域名对应ip	不允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com/a.js</span></div><div class="line">http:<span class="comment">//script.a.com/b.js	//主域相同，子域不同	不允许</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.a.com/a.js</span></div><div class="line">http:<span class="comment">//a.com/b.js	//同一域名，不同二级域名（同上）	不允许（cookie这种情况下也不允许访问）</span></div><div class="line"></div><div class="line">http:<span class="comment">//www.cnblogs.com/a.js</span></div><div class="line">http:<span class="comment">//www.a.com/b.js	//不同域名	不允许</span></div></pre></td></tr></table></figure>
<p>同源策略是浏览器的一种安全策略,不然互联网就真的数据共享了,哪里有版权和产权可言呢!所以JavaScript遵循老大的规矩，是不允许跨域调用其他页面的对象的.但是  哼哼  伟大的劳动人民魔高一丈.</p>
<p>##跨域方案</p>
<p>顶级域名相同的可以通过domain.name来解决，即同时设置 domain.name = 顶级域名（如example.com）</p>
<ul>
<li><p>document.domain + iframe</p>
</li>
<li><p>window.name + iframe</p>
</li>
<li><p>location.hash + iframe</p>
</li>
<li><p>window.postMessage()</p>
</li>
</ul>
<p><a href="http://rickgray.me/2015/09/03/solutions-to-cross-domain-in-browser.html" target="_blank" rel="external">大神解析</a></p>
<h2 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h2><blockquote>
<p>JSON with Padding其本质是利用了<script src=""></script>标签具有可跨域的特性，由服务端返回一个预先定义的Javascript函数的调用，并且将服务器数据以该函数参数的形式传递过来，此方法需要前后端配合完成。</p>
</blockquote>
<p>只能以get发送请求</p>
<ul>
<li>src只能发送get请求</li>
<li>jsonp也只能通过get请求</li>
<li>服务端代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php </div><div class="line">    $callBack = $_GET[<span class="string">'callback'</span>];</div><div class="line">    $arr = array(</div><div class="line">        <span class="string">'name'</span> =&gt;<span class="string">'西兰花'</span> ,</div><div class="line">        <span class="string">'color'</span> =&gt;<span class="string">'red'</span> </div><div class="line">         );</div><div class="line"></div><div class="line">    echo $callBack.<span class="string">"("</span>.json_encode($arr).<span class="string">")"</span>;</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<ul>
<li>前端代码:注意,域名不同<ul>
<li>核心是 通过script标签的src属性提交get请求</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">	&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang="en"&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset="UTF-8"&gt;</div><div class="line">    &lt;title&gt;Document&lt;/title&gt;</div><div class="line">    &lt;script type="text/javascript"&gt;</div><div class="line">        function fn(data)&#123;</div><div class="line">            console.log(data);</div><div class="line">        &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line">    &lt;script type="text/javascript" src='http://www.section02.com/seciton02_jsonP.php?callback=fn'&gt;&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;h1&gt;区域1的页面_jsonP演示&lt;/h1&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>##jQuery 的$.ajax()</p>
<blockquote>
<p>方法当中集成了JSONP的实现，可以非常方便的实现跨域数据的访问。</p>
</blockquote>
<p>dataType: ‘jsonp’ 设置dataType值为jsonp即开启跨域访问<br>jsonp 可以指定服务端接收的参数的“key”值，默认为callback<br>jsonpCallback 可以指定相应的回调函数，默认自动生成</p>
<pre><code>*实例代码
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">	&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang="en"&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset="UTF-8"&gt;</div><div class="line">    &lt;title&gt;Document&lt;/title&gt;</div><div class="line">    &lt;script type="text/javascript" src='jquery/jquery-3.0.0.min.js'&gt;&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;h1&gt;区域1的页面&lt;/h1&gt;</div><div class="line">    &lt;input type="button" name="" onclick='sendAjax()' value="jquery区域请求"&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">    function sendAjax()&#123;</div><div class="line">        $.ajax(&#123;</div><div class="line">            url:'http://www.section02.com/sectcion02_jqJsonp.php',</div><div class="line">            type:'post',</div><div class="line">            dataType: 'jsonp',</div><div class="line">            data:&#123;name:'itt'&#125;,</div><div class="line">            success:function(data)&#123;</div><div class="line">                console.log(data);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="跨域借口"><a href="#跨域借口" class="headerlink" title="跨域借口"></a>跨域借口</h2><blockquote>
<p>一些平台为我们提供了可以直接使用的接口,我们只需要按照他们提供的格式提交数据即可</p>
</blockquote>
<p><a href="http://developer.baidu.com/map/carapi-7.htm" target="_blank" rel="external">百度车联网api</a><br>开发者秘钥ak:0A5bc3c4fb543c8f9bc54b77bc155724</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;同源&quot;&gt;&lt;a href=&quot;#同源&quot; class=&quot;headerlink&quot; title=&quot;同源&quot;&gt;&lt;/a&gt;同源&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;要了解跨域,首先就要知道什么是同源?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所谓同源是指，域名，协议，端口完全相同&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="跨域" scheme="http://yoursite.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>很暗的</title>
    <link href="http://yoursite.com/2016/12/18/%E5%BE%88%E6%9A%97%E7%9A%84/"/>
    <id>http://yoursite.com/2016/12/18/很暗的/</id>
    <published>2016-12-17T17:06:31.582Z</published>
    <updated>2016-12-08T13:06:24.233Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>很久以前，我想过很多次以后的情景，我想过有一天我终于放弃你时候的样子。</p>
<p>我以为我会在某个晴朗的早晨，醒过来的刹那发现我不再喜欢你了，然后开始我的新生活。<br><a id="more"></a><br>然而我发现我错了。</p>
<p>其实是我开始了新生活之后，在潜移默化里，会在某一个平凡的时刻里，我乍然发现，我竟然已经忘记你很久了。</p>
<p>这种乍然是很悲哀的。</p>
<p>我总以为我与你的感情是伟大的，那它的消失也该是一件轰动的事情。</p>
<p>然而事实上它的消失是悄然无息的。</p>
<p>现在的某天里，我跟故友说，我好像喜欢上了一个人。<br>  故友也不会提起你的名字，而是安静地听我的新恋情。</p>
<p>偶尔会有人问起你——那xxx呢？还有联系么。<br>然后我才会想起你，一时间会不知道该说什么好了。</p>
<p>我曾经，是真的那样真实地喜欢过你。这种喜欢我想我此生大概都不会有第二次了。</p>
<p>你简直是我的全部。</p>
<p>跟你聊过的事，我还记得你对我的评价，记得你说的玩笑或者是真话。</p>
<p>也记得你说最近跟我说的最后一句话。</p>
<p>我记得你跟我说过的好听的话。</p>
<p>也记得你对我说过的残忍的话。</p>
<p>这么多的话我不知道我还会记得多久，我知道我回忆这些的时候还会有一点开心或者难过</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;很久以前，我想过很多次以后的情景，我想过有一天我终于放弃你时候的样子。&lt;/p&gt;
&lt;p&gt;我以为我会在某个晴朗的早晨，醒过来的刹那发现我不再喜欢你了，然后开始我的新生活。&lt;br&gt;
    
    </summary>
    
      <category term="杂记" scheme="http://yoursite.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="人生" scheme="http://yoursite.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>我想要的</title>
    <link href="http://yoursite.com/2016/12/18/%E6%97%A0%E9%A2%98/"/>
    <id>http://yoursite.com/2016/12/18/无题/</id>
    <published>2016-12-17T17:06:31.582Z</published>
    <updated>2016-12-17T09:21:36.677Z</updated>
    
    <content type="html"><![CDATA[<hr>
<blockquote>
<p>前段时间特别烦,看见代码就烦,一整天都在逛论坛,看知乎一些杂事野史,听歌逛评论,去贴吧骂人. 恍惚,难道真的是单身太久了? 以前看过一个故事,说一个人别待太久,至少养条狗也行.  细思极恐.<br>  <a id="more"></a><br>最近一直听学友的李香兰,低沉的嗓音,再配上粤语的歌词,竟然莫名的悲伤,悲伤就悲伤吧,我他妈还循环了一天.我们都是孤单的人儿呐.体己的人就那么两个,还他妈都不在身边,旁人谁会顾忌你第二天的情绪呢. </p>
<p>有时候就想啊,一个人跑到北京来干嘛,说真的. 还失眠.</p>
<p>有人说,是压力太大了,可是,还是他妈太闲了呢.</p>
<p>我一直想着系统的把ES6文档仔细读一遍,可是时间就是不知道都去哪儿了.笔记也做的七七八八,哪儿都有. 力拔山兮气盖世， 时不利兮骓不逝啊. 可是,可是,我忘了吗?小时候村东头的老王头说了,这孩子命脉通畅,足足有四两命呐,是干光宗耀祖大事的人呐.我忘了吗?我忘了二大爷眼中的期望么?我忘了郭皮皮钦佩的目光了吗?我没有,我是我们村第一个考上大学的孩子啊;我是我们村第一个看见黄河的年轻人呐;我每天都在知识的海洋里遨游,一次一次被拍打漆黑的礁石上,又一次次转身投入,只是为了弹奏灵魂的交响乐,只留给凡尘一条冗长冗长的背影,那看似满不在乎的转身，是我风干泪眼后萧瑟的影子啊. 心有猛虎,细嗅蔷薇. 我肩上扛得,是我们村的伟大复兴!</p>
<p>对啊,我是有历史使命的人啊,我能倒下吗?我能烦恼么?我能孤独么?  </p>
<p>聪明的孩子都变了.可是总要有人来坚持大家放弃了梦想啊,就让那些无缘的旧时光轻飘飘的溜走吧.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;前段时间特别烦,看见代码就烦,一整天都在逛论坛,看知乎一些杂事野史,听歌逛评论,去贴吧骂人. 恍惚,难道真的是单身太久了? 以前看过一个故事,说一个人别待太久,至少养条狗也行.  细思极恐.&lt;br&gt;
    
    </summary>
    
      <category term="杂记" scheme="http://yoursite.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="人生" scheme="http://yoursite.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>JS严格模式</title>
    <link href="http://yoursite.com/2016/12/18/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/12/18/严格模式/</id>
    <published>2016-12-17T17:06:31.520Z</published>
    <updated>2016-12-23T13:18:04.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ol>
<li>消除JavaScript语法的一些不合理、不严谨之处，减少一些怪异行为；</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>提高编译效率，增加运行效率；</li>
<li>为未来新版本的JavaScript做好铺垫。<a id="more"></a>
<h2 id="严格模式标记"><a href="#严格模式标记" class="headerlink" title="严格模式标记"></a>严格模式标记</h2></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div></pre></td></tr></table></figure>
<p>在老版本浏览器会将其当做一行普通字符串忽略。</p>
<h2 id="使用模式"><a href="#使用模式" class="headerlink" title="使用模式"></a>使用模式</h2><h3 id="针对整个脚本文件"><a href="#针对整个脚本文件" class="headerlink" title="针对整个脚本文件"></a>针对整个脚本文件</h3><p>将”use strict;”放在脚本文件的第一行，则整个脚本将以“严格模式”运行。如果此语句不放在第一行，则无效，整个脚本以“正常模式”运行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">　　<span class="string">"use strict"</span>;</div><div class="line">　　<span class="built_in">console</span>.log(<span class="string">"这是严格模式。"</span>);</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;script&gt;</div><div class="line">　　<span class="built_in">console</span>.log(<span class="string">"这是正常模式。"</span>);</div><div class="line">	<span class="string">"use strict"</span>;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h3 id="针对单个函数"><a href="#针对单个函数" class="headerlink" title="针对单个函数"></a>针对单个函数</h3><p>将”use strict;”放在函数体的第一行，则整个函数以”严格模式”运行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">strict</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">	"use strict"</span>;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"这是严格模式。"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">noStrict</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"这是正常模式。"</span>);</div><div class="line">	<span class="string">"use strict"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="脚本文件的变通写法"><a href="#脚本文件的变通写法" class="headerlink" title="脚本文件的变通写法"></a>脚本文件的变通写法</h3><p>由于第一种方式不利于文件合并，所以最好的做法是：将整个脚本文件放在一个沙箱模式（立即执行的匿名函数）中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">	"use strict"</span>;</div><div class="line">	<span class="comment">// 代码块</span></div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<h2 id="语法以及行为变化"><a href="#语法以及行为变化" class="headerlink" title="语法以及行为变化"></a>语法以及行为变化</h2><p>严格模式下，对JavaScript的语法和行为，都做一些变化。</p>
<h3 id="全局变量的隐式声明"><a href="#全局变量的隐式声明" class="headerlink" title="全局变量的隐式声明"></a>全局变量的隐式声明</h3><p>在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。但是在严格模式已禁止这种用法，全局变量必须显式声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line">v = <span class="number">1</span>; <span class="comment">// 报错，v is not defined。</span></div><div class="line"><span class="comment">// 在严格模式下，变量必须先使用var定义，在赋值。</span></div></pre></td></tr></table></figure>
<h3 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h3><p>JavaScript语言一个特点，就是允许”动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时确定的。</p>
<p>严格模式对动态绑定做一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，在编译阶段就确定。这样做有利于编译效率的提高，也使代码更易阅读，更少出现bug。</p>
<p>详细涉及以下几方面：</p>
<p>1.禁止使用with语句</p>
<p>由于with语句无法再编译阶段就确定 属性到底归属哪个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">var</span> v = <span class="number">1</span>;</div><div class="line"><span class="comment">// 报错，语法异常</span></div><div class="line"><span class="keyword">with</span>(o)&#123;</div><div class="line">	v = <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.eval作用域</p>
<p>正常模式，JavaScript语言具有两种变量作用域：全局作用域 和 函数作用域（局部作用域）。<br>严格模式，具有第三种作用域：eval作用域。</p>
<p>正常模式下，eval语句的作用域取决于 它处于全局作用域，还是函数作用域。<br>严格模式下，eval语句本身就是一个作用域，不再能够产生全局变量，其所生产的变量只能用于eval内部。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">"var x = 3; x"</span>)); <span class="comment">// 3</span></div><div class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>3.增强安全性</p>
<ul>
<li>在普通函数执行模式下，禁止this关键字指向全局对象.</li>
<li>因此，使用构造函数时，忘记new，this不再指向window对象，而是报错。就不会意外给window对象添加属性或方法。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">// window</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">	"use strict"</span>;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// undefined</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">	"use strict"</span>;</div><div class="line">	<span class="keyword">this</span>.name = <span class="string">"tom"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f = foo(); <span class="comment">// 报错</span></div></pre></td></tr></table></figure>
<p>4.禁止在函数内部访问caller以及arguments</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">	"use strict"</span>;</div><div class="line">	fn.caller;	  <span class="comment">// 报错</span></div><div class="line">	fn.arguments; <span class="comment">// 报错</span></div><div class="line">&#125;</div><div class="line">fn();</div></pre></td></tr></table></figure>
<p>5.禁止删除变量</p>
<p>在严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">var</span> x;</div><div class="line"><span class="keyword">delete</span> x; <span class="comment">// 报错</span></div><div class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(<span class="literal">null</span>, &#123;</div><div class="line">	<span class="string">"x"</span>: &#123;</div><div class="line">		<span class="attr">value</span>: <span class="number">10</span>,</div><div class="line">		<span class="attr">configurable</span>: <span class="literal">true</span></div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"><span class="keyword">delete</span> o.x; <span class="comment">// success</span></div></pre></td></tr></table></figure>
<p>6.显式报错</p>
<ul>
<li>在正常模式下，为一个对象的只读属性进行赋值，不会报错，只会默默的失败。<br>而严格模式下，会抛出异常。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"v"</span>, &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;);</div><div class="line">o.v = <span class="number">2</span>; <span class="comment">// 报错</span></div></pre></td></tr></table></figure>
<ul>
<li>严格模式下，对一个使用getter方法读取的属性进行赋值，会报错。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line">var o = &#123;</div><div class="line">	get v() &#123; return 1; &#125;</div><div class="line">&#125;;</div><div class="line">o.v = 2; // 报错</div></pre></td></tr></table></figure>
<ul>
<li>严格模式下，对禁止扩展的对象添加新属性，会报错。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.preventExtensions(o);</div><div class="line">o.v = <span class="number">1</span>; <span class="comment">// 报错</span></div></pre></td></tr></table></figure>
<ul>
<li>严格模式下，删除一个不可删除的属性，会报错。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype; <span class="comment">// 报错</span></div></pre></td></tr></table></figure>
<p>7.重名错误: 严格模式新增了一些语法错误。</p>
<ul>
<li>对象不能有重名的属性<br>正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">	<span class="attr">p</span>: <span class="number">1</span>,</div><div class="line">	<span class="attr">p</span>: <span class="number">2</span></div><div class="line">&#125;; <span class="comment">// 语法错误</span></div></pre></td></tr></table></figure>
<ul>
<li>函数不能有重名的参数<br>正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, a, b</span>) </span>&#123; <span class="comment">// 语法错误</span></div><div class="line">	<span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>8.禁止八进制表示法<br>正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">var</span> n = <span class="number">0100</span>; <span class="comment">// 语法错误</span></div></pre></td></tr></table></figure>
<h3 id="arguments对象的限制"><a href="#arguments对象的限制" class="headerlink" title="arguments对象的限制"></a>arguments对象的限制</h3><p>arguments是函数的参数对象，严格模式对它的使用做了限制。<br>1.不允许对arguments赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="built_in">arguments</span>++; <span class="comment">// 语法错误</span></div><div class="line"><span class="keyword">var</span> obj = &#123; set p(<span class="built_in">arguments</span>) &#123; &#125; &#125;; <span class="comment">// 语法错误</span></div><div class="line"><span class="keyword">try</span> &#123; &#125; <span class="keyword">catch</span> (<span class="built_in">arguments</span>) &#123; &#125; <span class="comment">// 语法错误</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">arguments</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// 语法错误</span></div><div class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"arguments"</span>, <span class="string">"'use strict'; return 17;"</span>); <span class="comment">// 语法错误</span></div></pre></td></tr></table></figure>
<p>2.arguments不再追踪参数的变化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">	a = <span class="number">2</span>;</div><div class="line">	<span class="keyword">return</span> [a, <span class="built_in">arguments</span>[<span class="number">0</span>]];</div><div class="line">&#125;</div><div class="line">f(<span class="number">1</span>); <span class="comment">// 正常模式为[2,2]</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</div><div class="line"><span class="meta">	"use strict"</span>;</div><div class="line">	a = <span class="number">2</span>;</div><div class="line">	<span class="keyword">return</span> [a, <span class="built_in">arguments</span>[<span class="number">0</span>]];</div><div class="line">&#125;</div><div class="line">f(<span class="number">1</span>); <span class="comment">// 严格模式为[2,1]</span></div></pre></td></tr></table></figure>
<p>3.禁止使用arguments.callee<br>这意味着，无法在匿名函数内部调用自身了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">arguments</span>.callee; &#125;;</div><div class="line">f(); <span class="comment">// 报错</span></div></pre></td></tr></table></figure>
<h3 id="函数必须声明在顶层"><a href="#函数必须声明在顶层" class="headerlink" title="函数必须声明在顶层"></a>函数必须声明在顶层</h3><p>将来Javascript的新版本会引入”块级作用域”。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// 语法错误</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// 语法错误</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><p>为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。<br>使用这些词作为变量名将会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">package</span>(<span class="params">protected</span>) </span>&#123; <span class="comment">// 语法错误</span></div><div class="line"><span class="meta">	"use strict"</span>;</div><div class="line">	<span class="keyword">var</span> implements; <span class="comment">// 语法错误</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;消除JavaScript语法的一些不合理、不严谨之处，减少一些怪异行为；&lt;/li&gt;
&lt;li&gt;消除代码运行的一些不安全之处，保证代码运行的安全；&lt;/li&gt;
&lt;li&gt;提高编译效率，增加运行效率；&lt;/li&gt;
&lt;li&gt;为未来新版本的JavaScript做好铺垫。
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>前端常见的小算法</title>
    <link href="http://yoursite.com/2016/12/18/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B0%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2016/12/18/前端常见的小算法/</id>
    <published>2016-12-17T17:06:31.520Z</published>
    <updated>2016-12-20T14:04:04.642Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>虽然说我们前端在工作中接触算法相对来说不多,但是一些常见的数据交互还是很重要的.下面我罗列一些常见的</p>
</blockquote>
 <a id="more"></a>
<h3 id="字符串翻转"><a href="#字符串翻转" class="headerlink" title="字符串翻转"></a>字符串翻转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function strReverse(str) &#123;</div><div class="line">	return str= str.split(&apos;&apos;).reverse().join(&apos;&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">方法一:</div><div class="line">  function quchong1(arr)&#123;</div><div class="line">            	var newArr=[];</div><div class="line">            	for(var i=0;i&lt;arr.length;i++)&#123;</div><div class="line">            		var flag=true;</div><div class="line">            		for(var j=0;j&lt;newArr.length;j++)&#123;</div><div class="line">            			if(arr[i]===newArr[j])&#123;</div><div class="line">            				flag=false;</div><div class="line">            			&#125;</div><div class="line">            		&#125;</div><div class="line">            		if(flag)&#123;</div><div class="line">            			newArr.push(arr[i]);</div><div class="line">            		&#125;</div><div class="line">            	&#125;</div><div class="line">            	return newArr;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">方法二:</div><div class="line">	 function quchong2(arr)&#123;</div><div class="line">            var newArr = [];</div><div class="line">            for(var i=0;i&lt;arr.length;i++)&#123;</div><div class="line">                for(var j=0;j&lt;newArr.length;j++)&#123;</div><div class="line">                    if(arr[i]===newArr[j])&#123;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if(j==newArr.length)&#123;</div><div class="line">                    newArr.push(arr[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return newArr</div><div class="line">        &#125;   </div><div class="line">方法三:</div><div class="line">	function quchong3(arr)&#123;</div><div class="line">		let hashtable = &#123;&#125;;</div><div class="line">		let data = [];</div><div class="line">		for (let i=0;i&lt;arr.length;i++)&#123;</div><div class="line">			if(!hashTable[arr[i]])&#123;</div><div class="line">				hashTable[arr[i]]= true;</div><div class="line">				data.push(arr[i]);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return data ;</div><div class="line">	&#125;	             </div><div class="line">	</div><div class="line">```     </div><div class="line"></div><div class="line">### 统计一个字符串出现最多的字母</div></pre></td></tr></table></figure>
<pre><code>function findMaxChar(str){
    if(str.length==1){
        return str;
    }
    let charObj={};
    for(let i,i&lt;str.length;i++){
        if(!charObj[str.charAt(i)]){
            charObj[str.charAt(i)]=1;
        }else{
            charObj[str.charAt(i)]+= 1;
        }
    }
    let maxChar = &apos;&apos;,
        maxValue= 1;
    for(var k in charObj){
        if(charObj[k]&gt;=maxValue){
            maxChar = k;
            maxValue = charObj[k];
        }
    }    
    return maxChar;
}
//暴露接口
module.exports = findMaxChar;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 冒泡排序(其实这玩意儿 .sort 就能搞定,但是.....)</div></pre></td></tr></table></figure>
<p>function bubbleSort(arr){<br>    for(let i=0;i<arr.length;i++){ for(let="" j="i+1;j<arr.length;j++){" if(arr[i]="">arr[j]){<br>                let item = arr[i];<br>                arr[i] = arr[j];<br>                arr[j] = item;<br>            }<br>        }<br>    }<br>    return arr;<br>}<br>//暴露接口<br>module.exports = bubbleSort;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">### 不借助临时变量,交换两个数值</div><div class="line"></div><div class="line">* 这种关键是跳出惯性思维,操作性其实也就那样</div></pre></td></tr></table></figure></arr.length;i++){></p>
<p>function swap(num1,num2){<br>    num2 = num1 - num2;<br>    num1 = num1 + num2;<br>    num2 = num1 - num2;<br>    return [num1,num2];<br>}<br>module.exports = swap;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">###	求n位斐波那契数列值</div></pre></td></tr></table></figure></p>
<p>function fibo(n){<br> if(n==2||n==1){<br>     return 1;<br> }<br> return fibo(n-1)+fibo(n-2);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 生成斐波那契数组</div></pre></td></tr></table></figure></p>
<p>function getFibo(n){<br>  var fibArr=[];<br>  var i= 0;<br>  while(i&lt;n){<br>      if(i&lt;=1){<br>        fibArr.push[i];<br>      }else {<br>          fibArr.push(fibArr[i-1] + fibArr[i-2])<br>      }<br>      i++;<br>  }<br>  return fibArr;<br>}<br>```</p>
<blockquote>
<p>暂时就想到这么多,这种小算法太多了,噌的一下还真想不太多,以后遇到慢慢往进添加吧. </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;虽然说我们前端在工作中接触算法相对来说不多,但是一些常见的数据交互还是很重要的.下面我罗列一些常见的&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="小算法(Algorithm)" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%AE%97%E6%B3%95-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Node 模块化简介</title>
    <link href="http://yoursite.com/2016/12/18/Node%20%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://yoursite.com/2016/12/18/Node 模块化/</id>
    <published>2016-12-17T17:06:31.504Z</published>
    <updated>2016-12-23T12:45:08.999Z</updated>
    
    <content type="html"><![CDATA[<p>##既然简单的写页面都知道外链css样式层和js行为层,那么前后端交互就更得模块分明不是</p>
<h3 id="1-模块简介"><a href="#1-模块简介" class="headerlink" title="1. 模块简介"></a>1. 模块简介</h3><ul>
<li><p>一个 js 文件就是一个模块</p>
</li>
<li><p>每个模块都是私有的作用域</p>
<a id="more"></a></li>
<li><p>每个模块内部都提供了一个接口对象：<code>module.exports</code></p>
<ul>
<li>可以通过给 <code>module.exports</code> 接口对象添加成员或者赋值对外提供接口接口对象</li>
</ul>
</li>
<li><p>为了方便，每个模块内部还为 <code>module.exports</code> 接口对象提供了一个别名： <code>exports</code> </p>
<ul>
<li>所以也可以通过给 <code>exports</code> 接口对象添加成员向外暴露</li>
</ul>
</li>
<li><p>如果想要向外暴露单个的成员（单个函数、单个变量等）</p>
<ul>
<li>则通过给 <code>module.exports</code> 接口对象赋值即可</li>
<li>注意：给 <code>exports</code> 赋值不管用<ul>
<li>因为每个模块内部最终暴露的接口对象是 <code>module.exports</code></li>
<li>所以给 <code>exports</code> 赋值会切断和 <code>module.exports</code> 之间的引用关系，是不管用的</li>
</ul>
</li>
</ul>
</li>
<li><p>在模块中，可以使用 <code>requrie</code> 函数加载执行指定模块</p>
<ul>
<li>调用 require 函数之后会执行被加载模块中的代码通过得到该模块中的 <code>module.exports</code> 接口对象</li>
</ul>
</li>
</ul>
<h3 id="2-自定义模块（用户自己编写的模块）"><a href="#2-自定义模块（用户自己编写的模块）" class="headerlink" title="2. 自定义模块（用户自己编写的模块）"></a>2. 自定义模块（用户自己编写的模块）</h3><p>以 <code>./</code> 或 <code>../</code> 开头的模块标识就是文件模块，一般就是用户编写的。</p>
<ul>
<li>require</li>
<li>module.exports</li>
<li>exports</li>
</ul>
<h3 id="3-核心模块（Node-内置）"><a href="#3-核心模块（Node-内置）" class="headerlink" title="3. 核心模块（Node 内置）"></a>3. 核心模块（Node 内置）</h3><ul>
<li>核心模块就是 node 内置的模块，需要通过唯一的标识名称来进行获取</li>
<li>每一个核心模块基本上都是暴露了一个对象，里面包含一些方法供我们使用</li>
<li>每一个核心模块都有自己的作用</li>
<li>一般在加载核心模块的时候，变量的起名最好就和核心模块的标识名同名即可<ul>
<li>例如：<code>var fs = require(&#39;fs&#39;)</code></li>
</ul>
</li>
<li>核心模块本质上也是文件模块<ul>
<li>核心模块已经被编译到了 node 的可执行程序，一般看不到</li>
<li>可以通过查看 node 的源码看到核心模块文件</li>
<li>核心模块也是基于模块化的方式编写的模块</li>
</ul>
</li>
</ul>
<p>每一个模块都提供了单一的功能，以下是常用的核心模块：</p>
<table>
<thead>
<tr>
<th>模块名称</th>
<th>模块作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>fs</td>
<td>文件操作</td>
</tr>
<tr>
<td>http</td>
<td>http服务</td>
</tr>
<tr>
<td>net</td>
<td>Socket网络编程</td>
</tr>
<tr>
<td>os</td>
<td>操作系统相关</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>path</td>
<td>路径操作</td>
</tr>
<tr>
<td>querystring</td>
<td>处理查询字符串</td>
</tr>
<tr>
<td>url</td>
<td>处理url路径</td>
</tr>
<tr>
<td>util</td>
<td>工具函数</td>
</tr>
</tbody>
</table>
<h3 id="4-第三方模块（也称作包，由社区提供）"><a href="#4-第三方模块（也称作包，由社区提供）" class="headerlink" title="4. 第三方模块（也称作包，由社区提供）"></a>4. 第三方模块（也称作包，由社区提供）</h3><h3 id="包与-Npm"><a href="#包与-Npm" class="headerlink" title="包与 Npm"></a>包与 Npm</h3><ul>
<li>包<ul>
<li>将相同业务功能的文件模块组织到一个目录中，那这个目录就称之为包</li>
<li>包就是文件模块的集合</li>
</ul>
</li>
<li>package.json 包说明文件</li>
<li>npm 网站<ul>
<li>npm 第一层含义就是包的托管网站</li>
<li>(<a href="https://www.npmjs.com/" target="_blank" rel="external">https://www.npmjs.com/</a>)</li>
</ul>
</li>
<li>npm 命令行工具<ul>
<li>Node 本身提供了一个包管理工具：npm Node Package Manage</li>
<li>npm 命令行工具可以安装和管理 Node 包</li>
<li>例如，安装 art-template</li>
<li>就可以使用 npm install art-template</li>
<li>想要在项目中使用，就可以使用这个工具来帮你安装就可以了</li>
<li>为什么要安装到项目根路径？</li>
<li>为什么使用   require(‘art-template’) 就可以使用模板引擎</li>
</ul>
</li>
</ul>
<h3 id="5-文件模块系统"><a href="#5-文件模块系统" class="headerlink" title="5. 文件模块系统"></a>5. 文件模块系统</h3><h4 id="在实际开发中建议用一下模块来整理文档文件。"><a href="#在实际开发中建议用一下模块来整理文档文件。" class="headerlink" title="在实际开发中建议用一下模块来整理文档文件。"></a>在实际开发中建议用一下模块来整理文档文件。</h4><ul>
<li><p>app.js</p>
<ul>
<li>创建服务器</li>
<li>监听request请求事件,设置请求处理函数,这个事件是所有请求的入口</li>
<li>绑定端口号,启动服务器</li>
</ul>
</li>
<li><p>router.js</p>
<ul>
<li>解析请求路径,根据不同的请求路径,分发到具体的处理函数    </li>
</ul>
</li>
<li><p>handler.js</p>
<ul>
<li>书写具体处理函数</li>
</ul>
</li>
<li><p>views文件</p>
<ul>
<li>用来存放请求的静态页面</li>
</ul>
</li>
<li><p>static文件</p>
<ul>
<li>用来存放静态页面所需的样式和图片</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##既然简单的写页面都知道外链css样式层和js行为层,那么前后端交互就更得模块分明不是&lt;/p&gt;
&lt;h3 id=&quot;1-模块简介&quot;&gt;&lt;a href=&quot;#1-模块简介&quot; class=&quot;headerlink&quot; title=&quot;1. 模块简介&quot;&gt;&lt;/a&gt;1. 模块简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个 js 文件就是一个模块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个模块都是私有的作用域&lt;/p&gt;
    
    </summary>
    
      <category term="NodeJs" scheme="http://yoursite.com/categories/NodeJs/"/>
    
    
      <category term="NodeJs" scheme="http://yoursite.com/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>Node js（基础）</title>
    <link href="http://yoursite.com/2016/12/18/Node%20JS%20%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/12/18/Node JS （基础）/</id>
    <published>2016-12-17T17:06:31.457Z</published>
    <updated>2016-12-23T12:40:59.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Node-js-介绍"><a href="#1-Node-js-介绍" class="headerlink" title="1. Node.js 介绍"></a>1. Node.js 介绍</h2><h3 id="1-1-网站开发模型（BS）"><a href="#1-1-网站开发模型（BS）" class="headerlink" title="1.1 网站开发模型（BS）"></a>1.1 网站开发模型（BS）</h3><ul>
<li>要认识NodeJs首先要知道了解网站开发模型，传统的网站开发模型就是BS模型，也就是浏览器服务器模型。</li>
<li><p>S（Server）：服务器端， 为客户端提交接口(数据)</p>
<ul>
<li>常用的服务器语言有：Java、.Net、Ruby、Python、PHP、Go、Swift、Lua<a id="more"></a> </li>
<li>简单来说服务器就是处理客户端的请求，做出处理之后并响应回去。</li>
</ul>
</li>
<li><p>B（Browser）：客户端，简单说就是把一坨用户看不懂的数据变成友好的形式给用户体验</p>
</li>
</ul>
<h3 id="1-2-什么是-Node-js？"><a href="#1-2-什么是-Node-js？" class="headerlink" title="1.2 什么是 Node.js？"></a>1.2 什么是 Node.js？</h3><ul>
<li><p>简单的说呢 </p>
<pre><code>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境
</code></pre></li>
<li><p>复杂的说呢就是:</p>
<pre><code>V8引 擎执行Javascript的速度非常快，性能非常好，Node.js对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好，也就是它对Google V8引擎进行了封装。
</code></pre></li>
<li><p>特点：            </p>
<pre><code>Node.js 使用高效、轻量级的事件驱动、非阻塞 I/O 模型
Node.js 的生态系统 npm 是目前最大的开源包管理系统
node.js 可跨平台 (Linux  windows  Unix)
</code></pre></li>
</ul>
<h3 id="1-3-使用-Node-可以做什么？"><a href="#1-3-使用-Node-可以做什么？" class="headerlink" title="1.3 使用 Node 可以做什么？"></a>1.3 使用 Node 可以做什么？</h3><pre><code>在几年的时间里，Node.JS逐渐发展成一个成熟的开发平台，吸引了许多开发者。有许多大型高流量网站都采用Node.JS进行开发，此外，开发人员还可以使用它来开发一些快速移动Web框架。除了Web应用外，NodeJS也被应用在许多方面，这些项目涉及到应用程序监控、媒体流、远程控制、桌面和移动应用等等。真的是很牛逼啊。
</code></pre><h3 id="1-4-Node-发展史"><a href="#1-4-Node-发展史" class="headerlink" title="1.4 Node 发展史"></a>1.4 Node 发展史</h3><p>####饮水思源嘛，人家开发出来，我们后来人总得记着</p>
<ul>
<li>Node.js 由 Ryan Dahl 和一些其他的开发者于2009年在 Joyent 工作时发明</li>
<li>2009年2月，Ryan Dahl在博客上宣布准备基于V8创建一个轻量级的Web服务器并提供一套库。</li>
<li>2009 年，Angular 诞生了</li>
<li>2009年5月，Ryan Dahl在GitHub上发布了最初版本的部分Node.js包，随后几个月里，有人开始使用Node.js开发应用。</li>
<li>2009年11月和2010年4月，两届JSConf大会都安排了Node.js的讲座。</li>
<li>2010年年底，Node.js获得云计算服务商Joyent资助，创始人Ryan Dahl加入Joyent全职负责Node.js的发展。</li>
<li>2011年7月，Node.js在微软的支持下发布Windows版本。</li>
</ul>
<h3 id="1-5-资源推荐"><a href="#1-5-资源推荐" class="headerlink" title="1.5 资源推荐"></a>1.5 资源推荐</h3><ul>
<li>深入浅出 Node.js</li>
<li>CNODE</li>
<li><a href="https://cnodejs.org/getstart" target="_blank" rel="external">Nodejs 新手入门</a></li>
</ul>
<h2 id="2-Node-js-关于-HTTP-处理过程"><a href="#2-Node-js-关于-HTTP-处理过程" class="headerlink" title="2. Node.js 关于 HTTP 处理过程"></a>2. Node.js 关于 HTTP 处理过程</h2><h3 id="2-1-Node-的网络应用都需要先创建一个网络服务对象，通过-createServer-来实现。"><a href="#2-1-Node-的网络应用都需要先创建一个网络服务对象，通过-createServer-来实现。" class="headerlink" title="2.1 Node 的网络应用都需要先创建一个网络服务对象，通过 createServer 来实现。"></a>2.1 Node 的网络应用都需要先创建一个网络服务对象，通过 createServer 来实现。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">	var http = require(&apos;http&apos;);</div><div class="line">	var server = http.createServer(function(request, response) &#123;   </div><div class="line">	// handle your requset </div><div class="line">	&#125;);</div><div class="line">```	</div><div class="line">###	2.2 传入 createServer 的 function 在每次 HTTP 请求时都将被调用执行，因此这个 function 也被称为请求的处理者。事实上通过 createServer 返回的 Server 对象是一个 EventEmitter，我们需要做的仅仅是在这里保存这个 server 对象，并在之后对其添加监听器。</div><div class="line">```	</div><div class="line">var http = require(&apos;http&apos;);</div><div class="line">var server = http.createServer(); </div><div class="line">server.on(&apos;request&apos;, function(request, response) &#123;</div><div class="line">// handle your requset </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="2-3-当-HTTP-请求这个服务时，node-调用请求处理者-function-并传入一些用于处理事务相关的对象：request-和-response。我们可以非常方便的获得这两个对象。"><a href="#2-3-当-HTTP-请求这个服务时，node-调用请求处理者-function-并传入一些用于处理事务相关的对象：request-和-response。我们可以非常方便的获得这两个对象。" class="headerlink" title="2.3 当 HTTP 请求这个服务时，node 调用请求处理者 function 并传入一些用于处理事务相关的对象：request 和 response。我们可以非常方便的获得这两个对象。"></a>2.3 当 HTTP 请求这个服务时，node 调用请求处理者 function 并传入一些用于处理事务相关的对象：request 和 response。我们可以非常方便的获得这两个对象。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var http = require(&apos;http&apos;);</div><div class="line">var server = http.createServer(); </div><div class="line">server.on(&apos;request&apos;, function(request, response) &#123;</div><div class="line">// handle your requset </div><div class="line">&#125;).listen(8080);</div></pre></td></tr></table></figure>
<h3 id="2-4-为了对实际的请求提供服务，在-server-对象上需要调用-listen-方法。绝大多数情况你需要传入-listen-你想要服务监听的端口号，这里也存在很多其他的可选方案"><a href="#2-4-为了对实际的请求提供服务，在-server-对象上需要调用-listen-方法。绝大多数情况你需要传入-listen-你想要服务监听的端口号，这里也存在很多其他的可选方案" class="headerlink" title="2.4 为了对实际的请求提供服务，在 server 对象上需要调用 listen 方法。绝大多数情况你需要传入 listen 你想要服务监听的端口号，这里也存在很多其他的可选方案."></a>2.4 为了对实际的请求提供服务，在 server 对象上需要调用 listen 方法。绝大多数情况你需要传入 listen 你想要服务监听的端口号，这里也存在很多其他的可选方案.</h3><h2 id="3-Node中的-JavaScript"><a href="#3-Node中的-JavaScript" class="headerlink" title="3. Node中的 JavaScript"></a>3. Node中的 JavaScript</h2><ul>
<li><em>console</em></li>
<li><em>setInterval(callback, delay[, …args])</em></li>
<li><em>setTimeout(callback, delay[, …args])</em></li>
<li><em>clearInterval(intervalObject)</em></li>
<li><em>clearTimeout(timeoutObject)</em></li>
<li>clearImmediate(immediateObject)</li>
<li>setImmediate(callback[, …args])</li>
<li>__dirname</li>
<li>__filename</li>
<li>module</li>
<li>exports</li>
<li>global</li>
<li>process</li>
<li>require()</li>
</ul>
<h2 id="4-文件操作"><a href="#4-文件操作" class="headerlink" title="4.文件操作"></a>4.文件操作</h2><h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><ul>
<li>path.basename(path[, ext])：获取文件名部分</li>
<li>path.dirname(path)：获取目录部分</li>
<li>path.extname(path)：获取扩展名部分</li>
<li>path.isAbsolute(path)：判断是否是绝对路径</li>
<li>path.join([…paths])：将多个路径拼接为一个路径</li>
</ul>
<h3 id="同步调用与异步调用"><a href="#同步调用与异步调用" class="headerlink" title="同步调用与异步调用"></a>同步调用与异步调用</h3><p>fs模块对文件的几乎所有操作都有同步和异步两种形式，例如：<code>readFile()</code> 和 <code>readFileSync()</code>。</p>
<p>同步与异步文件系统调用的区别</p>
<ul>
<li>同步调用立即执行，会阻塞后续代码继续执行，如果想要捕获异常需要使用 <code>try-catch</code></li>
<li>异步调用不会阻塞后续代码继续执行，需要回调函数作为额外的参数，通常包含一个错误作为回调函数的第一个参数</li>
<li>异步调用通过判断第一个err对象来处理异常</li>
<li>异步调用结果往往通过回调函数来进行获取</li>
</ul>
<p>Node 只在文件IO操作中，提供了同步调用和异步调用两种形式，两者可以结合使用，<br>但是推荐能使用异步调用解决问题的情况下，少用同步调用。</p>
<h3 id="文件操作常用API"><a href="#文件操作常用API" class="headerlink" title="文件操作常用API"></a>文件操作常用API</h3><ul>
<li>fs.writeFile(file, data, callback)：文件写入</li>
<li>fs.appendFile(file, data, callback)：文件追加</li>
<li>fs.readFile(file[, options], callback)：文件读取</li>
<li>fs.unlink(path, callback)：删除文件</li>
<li>fs.stat(path, callback)：获取文件信息</li>
<li>fs.access(path, callback)：验证文件路径是否存在</li>
<li>fs.rename(oldPath, newPath, callback)：重命名或移动文件</li>
</ul>
<h3 id="目录操作常用API"><a href="#目录操作常用API" class="headerlink" title="目录操作常用API"></a>目录操作常用API</h3><ul>
<li>fs.mkdir(path, callback)：创建一个目录</li>
<li>fs.rmdir(path, callback)：删除一个空目录</li>
<li>fs.readdir(path, callback)：读取一个目录</li>
<li>fs.rename(oldPath, newPath, callback)：重命名或移动目录</li>
</ul>
<h2 id="5-HTTP"><a href="#5-HTTP" class="headerlink" title="5. HTTP"></a>5. HTTP</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul>
<li><p>Server</p>
<ul>
<li>http.createServer([requestListener])</li>
<li>Event: ‘request’</li>
<li>Event: ‘close’</li>
<li>Event: ‘connection’</li>
<li>server.close([callback])</li>
<li>server.listen([port][, hostname][, backlog][, callback])</li>
</ul>
</li>
<li><p>Request</p>
<ul>
<li>Event: ‘data’</li>
<li>Event: ‘close’</li>
<li>message.headers</li>
<li>message.httpVersion</li>
<li>message.method</li>
<li>message.url</li>
</ul>
</li>
<li><p>Response</p>
<ul>
<li>response.write(chunk[, encoding][, callback])</li>
<li>response.end([data][, encoding][, callback])</li>
<li>response.writeHead(statusCode[, statusMessage][, headers])</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Node-js-介绍&quot;&gt;&lt;a href=&quot;#1-Node-js-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. Node.js 介绍&quot;&gt;&lt;/a&gt;1. Node.js 介绍&lt;/h2&gt;&lt;h3 id=&quot;1-1-网站开发模型（BS）&quot;&gt;&lt;a href=&quot;#1-1-网站开发模型（BS）&quot; class=&quot;headerlink&quot; title=&quot;1.1 网站开发模型（BS）&quot;&gt;&lt;/a&gt;1.1 网站开发模型（BS）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;要认识NodeJs首先要知道了解网站开发模型，传统的网站开发模型就是BS模型，也就是浏览器服务器模型。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;S（Server）：服务器端， 为客户端提交接口(数据)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常用的服务器语言有：Java、.Net、Ruby、Python、PHP、Go、Swift、Lua
    
    </summary>
    
      <category term="NodeJs" scheme="http://yoursite.com/categories/NodeJs/"/>
    
    
      <category term="NodeJs" scheme="http://yoursite.com/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>ES5数组新增Api</title>
    <link href="http://yoursite.com/2016/12/18/ES5-%E6%95%B0%E7%BB%84%E6%96%B0%E5%A2%9E%E7%9A%84%E5%87%A0%E4%B8%AAApi/"/>
    <id>http://yoursite.com/2016/12/18/ES5-数组新增的几个Api/</id>
    <published>2016-12-17T17:06:31.442Z</published>
    <updated>2016-12-07T13:48:08.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="forEach-callback-thisArg"><a href="#forEach-callback-thisArg" class="headerlink" title="forEach(callback[thisArg])"></a>forEach(callback[thisArg])</h2><ul>
<li>在ES5之前，我们可以通过for和for in 两种方式来遍历数组，而ES5引入了一个新方法forEach，使数组遍历更加简洁，forEach需要传递2个参数，第一个参数是回调函数，是必选参数，第二个参数是一个对象，用来改变callback中的this指向，是可选参数。<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</div><div class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v,i,r</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(v,i,r);</div><div class="line">&#125;)</div><div class="line">-&gt;</div><div class="line">a <span class="number">0</span> [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</div><div class="line">b <span class="number">1</span> [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</div><div class="line">c <span class="number">2</span> [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</div></pre></td></tr></table></figure>
</li>
</ul>
<p>从输出的结果可以看出，callback中传入了3个参数v,i,r 分别表示当前元素、当前位置、数组对象.再看看使用 thisArg 的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">   <span class="attr">print</span>:<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(a,b);</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</div><div class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v,i,a</span>)</span>&#123;</div><div class="line">   <span class="keyword">this</span>.print(v,i);</div><div class="line">&#125;,obj);</div></pre></td></tr></table></figure>
<p>不传thisArgs时，callback中的 this 默认指向 window 对象，当传递thisArg时，callback中的this就指向了thisArg，因此这个参数的目的就是为了改变回调函数中的this指向。</p>
<ul>
<li>对于不支持ES5的浏览器，我们可以对forEach进行简单的扩展来兼容老的浏览器：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!<span class="built_in">Array</span>.prototype.forEach)&#123;</div><div class="line">    <span class="built_in">Array</span>.prototype.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">callback,thisArg</span>)</span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++)&#123;</div><div class="line">            <span class="comment">//当thisArg为undefined时，JS引擎会将window作为其调用者</span></div><div class="line">            callback.call(thisArg,<span class="keyword">this</span>[i],i,<span class="keyword">this</span>.toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="map-callback-thisArg"><a href="#map-callback-thisArg" class="headerlink" title="map(callback[,thisArg])"></a>map(callback[,thisArg])</h2><ul>
<li>map的作用是对原数组进行加工处理后并将其作为一个新数组返回，该方法同样接收两个参数，callback是回调函数用于对数组进行加工处理，thisArg和上面的一样。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [</div><div class="line">   &#123;<span class="attr">w</span>:<span class="number">10</span>,<span class="attr">h</span>:<span class="number">10</span>&#125;, <span class="comment">//定义长和宽</span></div><div class="line">   &#123;<span class="attr">w</span>:<span class="number">15</span>,<span class="attr">h</span>:<span class="number">20</span>&#125;,</div><div class="line">   &#123;<span class="attr">w</span>:<span class="number">12</span>,<span class="attr">h</span>:<span class="number">12</span>&#125;</div><div class="line">];</div><div class="line"><span class="keyword">var</span> newArr = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">   <span class="comment">//根据长宽计算出面积并赋值给新属性area </span></div><div class="line">   item.area = item.w * item.h;</div><div class="line">   <span class="keyword">return</span> item;</div><div class="line">&#125;);</div><div class="line">newArr[<span class="number">0</span>] - &gt; &#123;<span class="attr">w</span>: <span class="number">10</span>, <span class="attr">h</span>: <span class="number">10</span>, <span class="attr">area</span>: <span class="number">100</span>&#125;</div></pre></td></tr></table></figure>
<p>可以看出，newArr返回的是增加了area属性的对象数组。这个方法非常实用，一般情况下，当一个ajax请求返回时，我们都要对其结果集进行过滤和校验等操作，这时map就派上用场了。我们再看看如果对map进行兼容性扩展：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!<span class="built_in">Array</span>.prototype.map) &#123;</div><div class="line">   <span class="built_in">Array</span>.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">callback, thisArg</span>) </span>&#123;</div><div class="line">       <span class="keyword">var</span> temp = [];</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</div><div class="line">           <span class="keyword">var</span> newItem = callback.call(thisArg,<span class="keyword">this</span>[i]);</div><div class="line">           temp.push(newItem); <span class="comment">//将callback返回的新元素压入temp中</span></div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> temp;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="filter-callback-thisArg"><a href="#filter-callback-thisArg" class="headerlink" title="filter(callback[thisArg])"></a>filter(callback[thisArg])</h2><ul>
<li>filter是<code>过滤</code>的意思，所以这个方法的作用就是返回一个匹配过滤条件的新数组，其接收两个参数callback和thisArg, callback也是回调函数，主要用于对元素进行条件匹配，thisArg和forEach中的thisArg作用一样，在这里就不重复了，看下面示例：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"a"</span>,<span class="string">"c"</span>];</div><div class="line"><span class="keyword">var</span> newArr = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">     <span class="keyword">return</span> item === <span class="string">"a"</span>;</div><div class="line">&#125;);</div><div class="line">       </div><div class="line">newArr -&gt; [<span class="string">"a"</span>,<span class="string">"a"</span>]</div></pre></td></tr></table></figure>
<p>代码很简单，一看就明白，没有filter的时候，要实现这个功能，我们事先要创建一个空的数组，把匹配到的元素再push进去，现在就不需要那么麻烦了，我们再看看对filter的扩展：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!<span class="built_in">Array</span>.prototype.filter) &#123;</div><div class="line">    <span class="built_in">Array</span>.prototype.filter = <span class="function"><span class="keyword">function</span> (<span class="params">callback, thisArg</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> temp = [];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</div><div class="line">           <span class="keyword">if</span>(callback.call(thisArg,<span class="keyword">this</span>[i]))&#123;</div><div class="line">               <span class="comment">//如果callback返回true,则该元素符合过滤条件，将元素压入temp中</span></div><div class="line">               temp.push(<span class="keyword">this</span>[i]);</div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="some-callback-thisArg"><a href="#some-callback-thisArg" class="headerlink" title="some (callback[,thisArg])"></a>some (callback[,thisArg])</h2><ul>
<li>some是<code>某些、一些</code>的意思，因此，some的作用是检测数组中的每一个元素，当callback返回true时就停止遍历，并返回true，这样的描述似乎有些抽象，看代码：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">var</span> result = arr.some( <span class="function"><span class="keyword">function</span>(<span class="params"> item, index, array </span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( item, index, array);</div><div class="line">    <span class="keyword">return</span> item &gt; <span class="number">2</span>;</div><div class="line">&#125;);</div><div class="line">-&gt;</div><div class="line"> <span class="number">1</span> <span class="number">0</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"> <span class="number">2</span> <span class="number">1</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"> <span class="number">3</span> <span class="number">2</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"></div><div class="line"> restule -&gt; <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>从运行结果看，some检测整个数组，只要当arr中有一个元素符合条件item&gt;2 就停止检测和遍历，并返回true，以表示检测到目标。这和我们在for循环中使用break语言的作用有点类似！ 下面对于some的扩展会有助于你对some的理解：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!<span class="built_in">Array</span>.prototype.some) &#123;</div><div class="line">   <span class="built_in">Array</span>.prototype.some = <span class="function"><span class="keyword">function</span> (<span class="params">callback, thisArg</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</div><div class="line">           <span class="keyword">if</span>(callback.call(thisArg,<span class="keyword">this</span>[i],i,<span class="keyword">this</span>.toString()))&#123;</div><div class="line"></div><div class="line">               <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//检测到callback返回true,跳出循环，并返回true</span></div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//一个符合条件的都没有检测到，返回false</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="every-callback-thisArg"><a href="#every-callback-thisArg" class="headerlink" title="every (callback[,thisArg])"></a>every (callback[,thisArg])</h2><ul>
<li>every是<code>每一个</code>的意思，相比some来讲，every对元素的检测更加严格，那every到底是干什么的呢，看代码：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">var</span> result = arr.every( <span class="function"><span class="keyword">function</span>(<span class="params"> item, index, array </span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( item, index, array );</div><div class="line">    <span class="keyword">return</span> item &lt; <span class="number">3</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"> <span class="number">1</span> <span class="number">0</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"> <span class="number">2</span> <span class="number">1</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"> <span class="number">3</span> <span class="number">2</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"></div><div class="line"> result -&gt; <span class="literal">false</span></div></pre></td></tr></table></figure>
<p> 从运行结果看，当检测第3个元素时，item&lt;3为false, 停止检测，并返回false，这说明every在检测元素时，要求每一个元素都要符合条件item&lt;3，如果有一个不符合就停止检测，并返回false,(ps：你可以测试item&lt;5时的运行结果，返回值一定是true)。那every到底有什么用武之地呢？ 当一个for循环使用了break语句后，我们想知道for循环是否正常的执行完时， 我们一般会通过检测for中的索引i==arr.length来判断,因此every的作用就体现在这里。 我们再看看对于every方法的扩展：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!<span class="built_in">Array</span>.prototype.every) &#123;</div><div class="line">   <span class="built_in">Array</span>.prototype.every = <span class="function"><span class="keyword">function</span> (<span class="params">callback, thisArg</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</div><div class="line">           <span class="keyword">if</span>(!callback.call(thisArg,<span class="keyword">this</span>[i],i,<span class="keyword">this</span>.toString()))&#123;</div><div class="line"></div><div class="line">               <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//检测到不符合条件的元素,跳出循环，并返回false</span></div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//所有元素都符合条件，返回true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="reduce-callback-initialValue"><a href="#reduce-callback-initialValue" class="headerlink" title="reduce(callback[initialValue])"></a>reduce(callback[initialValue])</h2><ul>
<li>官方解释:该方法应用一个函数对一个累加器和数组的每个值(从左到右)减少到一个单一值(什么玩意儿嘛)<br>*代码如下:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line"><span class="keyword">var</span> newArr = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">previousValue, currentValue, currentIndex, array</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(previousValue, currentValue,currentIndex);</div><div class="line">    <span class="keyword">return</span> previousValue + currentValue;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></div><div class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">2</span></div><div class="line"><span class="number">6</span> <span class="number">4</span> <span class="number">3</span></div><div class="line"></div><div class="line">newArr -&gt; <span class="number">10</span></div></pre></td></tr></table></figure>
<p>从运行结果可以看出，reduce实现了数组元素的累加功能，reduce接收4个参数，previousValue存放的是上一次callback返回的结果，currentValue是当前元素，currentIndex是当前元素位置，array是当前数组。</p>
<ul>
<li>previousValue 初始值为数组的第一个元素，数组从第2个元素开始遍历。我们再来看看initialValue 究竟是什么鬼：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line"><span class="keyword">var</span> newArr = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">previousValue, currentValue, currentIndex, array</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(previousValue, currentValue,currentIndex);</div><div class="line">    <span class="keyword">return</span> previousValue + currentValue;</div><div class="line">&#125;,<span class="number">100</span>);</div><div class="line"></div><div class="line"><span class="number">100</span> <span class="number">1</span> <span class="number">0</span></div><div class="line"><span class="number">101</span> <span class="number">2</span> <span class="number">1</span></div><div class="line"><span class="number">103</span> <span class="number">3</span> <span class="number">2</span></div><div class="line"><span class="number">106</span> <span class="number">4</span> <span class="number">3</span></div><div class="line"></div><div class="line">newArr -&gt; <span class="number">110</span></div></pre></td></tr></table></figure>
<p>从运行结果看，initialValue参数指定了previousValue的初始值，更重要的是，这次数组是从第1个位置开始遍历，而不再是从第2个位置开始了。</p>
<h2 id="reduceRight-callback-initialValue"><a href="#reduceRight-callback-initialValue" class="headerlink" title="reduceRight (callback[,initialValue])"></a>reduceRight (callback[,initialValue])</h2><ul>
<li>和reduce的作用完全相同，唯一的不同是，reduceRight是从右至左遍历数组的元素。</li>
</ul>
<h2 id="indexOf-和-lastIndexOf"><a href="#indexOf-和-lastIndexOf" class="headerlink" title="indexOf##和## lastIndexOf"></a>indexOf##和## lastIndexOf</h2><ul>
<li>这两个方法和String类中indexOf和lastIndexOf作用类似</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;forEach-callback-thisArg&quot;&gt;&lt;a href=&quot;#forEach-callback-thisArg&quot; class=&quot;headerlink&quot; title=&quot;forEach(callback[thisArg])&quot;&gt;&lt;/a&gt;forEach(callback[thisArg])&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在ES5之前，我们可以通过for和for in 两种方式来遍历数组，而ES5引入了一个新方法forEach，使数组遍历更加简洁，forEach需要传递2个参数，第一个参数是回调函数，是必选参数，第二个参数是一个对象，用来改变callback中的this指向，是可选参数。
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
</feed>
